package main

import (
	"fmt"
	"go/build"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"strings"
)

// MapperGenerator generates struct-to-struct mapping code
type MapperGenerator struct {
	InterfaceType reflect.Type
	PackagePath   string
	PackageDir    string
}

// NewMapperGenerator creates a new instance of MapperGenerator
func NewMapperGenerator(interfaceType interface{}) error {
	typ := reflect.TypeOf(interfaceType)

	// Handle pointer to interface
	if typ.Kind() == reflect.Ptr {
		typ = typ.Elem()
	}

	if typ.Kind() != reflect.Interface {
		log.Fatalf("NewMapperGenerator expects interface but got %s", typ.Kind())
	}

	pkgPath := typ.PkgPath()
	if pkgPath == "" {
		log.Fatalf("unable to determine package path for interface %v", typ)
	}

	// Determine the directory of the interface file
	pkgDir := getPackageDir(pkgPath)
	if pkgDir == "" {
		log.Fatalf("unable to locate package directory for %s", pkgPath)
	}

	gen := &MapperGenerator{
		InterfaceType: typ,
		PackagePath:   pkgPath,
		PackageDir:    pkgDir,
	}
	return gen.WriteToFile()
}

func getPackageDir(pkgPath string) string {
	// Use the build package to find the directory of the package
	pkg, err := build.Import(pkgPath, ".", build.FindOnly)
	if err != nil {
		log.Fatalf("failed to resolve package directory for %s: %v", pkgPath, err)
	}

	return pkg.Dir
}

// GenerateCode generates the mapper implementation for the interface
func (g *MapperGenerator) GenerateCode() (string, error) {
	var sb strings.Builder

	interfaceName := g.InterfaceType.Name()
	if interfaceName == "" {
		return "", fmt.Errorf("interface must have a name")
	}

	// Generate imports
	imports := g.generateImports()

	// Start building the file content
	sb.WriteString(fmt.Sprintf("package %s\n\n", g.getPackageName()))
	sb.WriteString(imports)
	sb.WriteString("// Code generated by STOS [structToStructMapper]\n// DO NOT EDIT\n\n")
	sb.WriteString(fmt.Sprintf("type %sImpl struct {}\n\n", strings.ToLower(interfaceName[:1])+interfaceName[1:]))
	sb.WriteString(g.generateConstructorStub(interfaceName))

	for i := 0; i < g.InterfaceType.NumMethod(); i++ {
		method := g.InterfaceType.Method(i)
		sb.WriteString(g.generateMethodStub(method))
	}

	return sb.String(), nil
}

func (g *MapperGenerator) generateConstructorStub(interfaceName string) string {
	var sb strings.Builder
	titleInterface := strings.ToLower(interfaceName[:1]) + interfaceName[1:]
	// Generate method signature
	sb.WriteString(fmt.Sprintf("func New%sImpl() %s {\n", interfaceName, interfaceName))

	// Generate mapping logic
	sb.WriteString(fmt.Sprintf("\treturn &%sImpl{}\n", titleInterface))
	sb.WriteString("}\n\n")
	return sb.String()
}

// generateImports creates the necessary imports for the generated code
func (g *MapperGenerator) generateImports() string {
	importSet := make(map[string]bool)

	// Iterate over the methods of the interface to gather unique packages
	for i := 0; i < g.InterfaceType.NumMethod(); i++ {
		method := g.InterfaceType.Method(i)

		// Inspect method input parameters
		for j := 0; j < method.Type.NumIn(); j++ { // Skip the first parameter (receiver)
			g.addPackageToImportSet(method.Type.In(j), importSet)
		}

		// Inspect method output parameters
		for j := 0; j < method.Type.NumOut(); j++ {
			g.addPackageToImportSet(method.Type.Out(j), importSet)
		}
	}

	// Convert the set to a slice
	imports := make([]string, 0, len(importSet))
	for pkgPath := range importSet {
		imports = append(imports, fmt.Sprintf("\"%s\"", pkgPath))
	}

	// Generate the import block
	return "import (\n" + strings.Join(imports, "\n") + "\n)\n\n"
}

// addPackageToImportSet recursively adds the package path of a type and its fields to the import set
func (g *MapperGenerator) addPackageToImportSet(typ reflect.Type, importSet map[string]bool) {
	// Dereference pointer types
	for typ.Kind() == reflect.Ptr {
		typ = typ.Elem()
	}

	// Add the package path of the current type
	if typ.PkgPath() != "" && typ.PkgPath() != g.PackagePath {
		importSet[typ.PkgPath()] = true
	}

	// If the type is a struct, recursively process its fields
	if typ.Kind() == reflect.Struct {
		for i := 0; i < typ.NumField(); i++ {
			field := typ.Field(i)
			g.addPackageToImportSet(field.Type, importSet)
		}
	}
}

// generateMethodStub creates a method stub based on the interface's method signature
func (g *MapperGenerator) generateMethodStub(method reflect.Method) string {
	var sb strings.Builder

	methodName := method.Name

	// Ensure the method has a valid signature
	if method.Type.NumIn() < 1 || method.Type.NumOut() < 1 {
		log.Fatalf("Method %s must have one input parameter (source struct) and one output parameter (target struct)", methodName)
	}

	// Extract source and target types
	sourceType := method.Type.In(0)
	targetType := method.Type.Out(0)
	implName := g.InterfaceType.Name()

	// Generate method signature
	sb.WriteString(fmt.Sprintf("func (impl *%sImpl) %s(source %s) %s {\n",
		strings.ToLower(implName[:1])+implName[1:], methodName, sourceType.String(), targetType.String()))

	// Generate mapping logic
	sb.WriteString(fmt.Sprintf("\ttarget := %s{}\n", targetType.String()))
	sb.WriteString(g.generateFieldMappings(sourceType, targetType))
	sb.WriteString("\treturn target\n")
	sb.WriteString("}\n\n")

	return sb.String()
}

// generateFieldMappings generates field mapping logic for structs
func (g *MapperGenerator) generateFieldMappings(sourceType, targetType reflect.Type) string {
	var sb strings.Builder

	// Ensure both source and target are structs
	if sourceType.Kind() != reflect.Struct || targetType.Kind() != reflect.Struct {
		return "\t// TODO: Non-struct mappings not implemented\n"
	}

	// Iterate over fields of source struct
	for i := 0; i < sourceType.NumField(); i++ {
		sourceField := sourceType.Field(i)
		targetField, found := targetType.FieldByName(sourceField.Name)

		// Match fields by name and type
		if found && sourceField.Type == targetField.Type {
			sb.WriteString(fmt.Sprintf("\ttarget.%s = source.%s\n", targetField.Name, sourceField.Name))
		} else if found && sourceField.Type.Kind() == reflect.Struct && targetField.Type.Kind() == reflect.Struct {
			// Nested struct mapping
			sb.WriteString(fmt.Sprintf("\t// Nested struct mapping: %s\n", sourceField.Name))
			sb.WriteString(fmt.Sprintf("\ttarget.%s = impl.%s(source.%s)\n", targetField.Name, g.generateNestedMappingMethod(sourceField.Type, targetField.Type), sourceField.Name))
		}
	}

	return sb.String()
}

// generateNestedMappingMethod handles nested struct mapping (can be recursive)
func (g *MapperGenerator) generateNestedMappingMethod(sourceType, targetType reflect.Type) string {
	// Create a helper function name for nested mapping
	return fmt.Sprintf("map%sTo%s", sourceType.Name(), targetType.Name())
}

// generateConstructor generates the constructor for the implementation
func (g *MapperGenerator) generateConstructor() string {
	return fmt.Sprintf("func New%sImpl() *%sImpl {\n\treturn &%sImpl{}\n}\n\n",
		g.InterfaceType.Name(), strings.ToLower(g.InterfaceType.Name()), strings.ToLower(g.InterfaceType.Name()))
}

// generateImplementation generates the full implementation
func (g *MapperGenerator) generateImplementation(interfaceName string) string {
	var sb strings.Builder

	// Generate package and import statements
	sb.WriteString("// Code generated by MapperGenerator\n")
	sb.WriteString(fmt.Sprintf("package %s\n\n", "main")) // Assuming "main" for simplicity
	sb.WriteString("import (\n")
	sb.WriteString("\t\"reflect\"\n") // Example import; update based on actual use
	sb.WriteString(")\n\n")

	// Generate private implementation struct
	sb.WriteString(fmt.Sprintf("type %sImpl struct {}\n\n", strings.ToLower(interfaceName)))

	// Generate constructor
	sb.WriteString(g.generateConstructor())

	// Generate methods
	for i := 0; i < g.InterfaceType.NumMethod(); i++ {
		method := g.InterfaceType.Method(i)
		sb.WriteString(g.generateMethodStub(method))
	}

	return sb.String()
}

// generateParameters generates parameter or return type definitions
func (g *MapperGenerator) generateParameters(typ reflect.Type, start, end int) string {
	var params []string
	for i := start; i < end; i++ {
		paramType := typ.In(i)
		param := fmt.Sprintf("arg%d %s", i, paramType.String())
		params = append(params, param)
	}
	return strings.Join(params, ", ")
}

// getPackageName extracts the package name from the package path
func (g *MapperGenerator) getPackageName() string {
	parts := strings.Split(g.PackagePath, "/")
	return parts[len(parts)-1]
}

// WriteToFile writes the generated code to the same folder as the interface file
func (g *MapperGenerator) WriteToFile() error {
	code, err := g.GenerateCode()
	if err != nil {
		return err
	}

	interfaceName := strings.ToLower(g.InterfaceType.Name()[:1]) + g.InterfaceType.Name()[1:]

	fileName := fmt.Sprintf("%sImpl.go", interfaceName)
	filePath := filepath.Join(g.PackageDir, fileName)

	if err := os.MkdirAll(g.PackageDir, os.ModePerm); err != nil {
		return fmt.Errorf("failed to create directory: %v", err)
	}

	if _, err := os.Stat(fileName); err == nil {
		// If the file exists, remove it before creating a new one
		err := os.Remove(fileName)
		if err != nil {
			return fmt.Errorf("failed to remove existing file: %v", err)
		}
	}

	file, err := os.Create(filePath)
	if err != nil {
		return fmt.Errorf("failed to create file: %v", err)
	}
	defer file.Close()

	_, err = file.WriteString(code)
	if err != nil {
		return fmt.Errorf("failed to write to file: %v", err)
	}

	return nil
}
